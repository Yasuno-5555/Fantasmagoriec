# Architecture Overview

Fantasmagorie Crystal is designed around a strict separation of concerns between **State**, **Layout**, and **Rendering**.

## 1. High-Level Diagram

```mermaid
graph TD
    UserCode[User App Code] -->|Calls Fanta API| Builder[Element Builder]
    Builder -->|Writes| FrameState[Frame Elements (Transient)]
    
    subgraph Core Engine
        Scheduler[Scheduler / Loop]
        StateStore[State Store (Persistent)]
        LayoutEngine[Layout Engine]
        RenderTree[Render Tree Walker]
    end
    
    Scheduler -->|BeginFrame| Builder
    Scheduler -->|EndFrame| LayoutEngine
    
    LayoutEngine -->|Read| FrameState
    LayoutEngine -->|Compute| LayoutResults[Layout Results]
    
    RenderTree -->|Read| FrameState
    RenderTree -->|Read| LayoutResults
    RenderTree -->|Read/Write| StateStore
    RenderTree -->|Generates| DrawList[Draw Command List]
    
    DrawList -->|Submit| Backend[Rendering Backend]
    Backend -->|Draw| GPU[Screen]
```

## 2. Core Concepts

### The Element Builder
The `fanta::Element` class is a transient, stack-allocated builder. It does not "own" the element. When you call methods like `.size()` or `.bg()`, it writes directly to the `FrameState` arena in the current context.

### The ID System
Every element has a stable `ID`.
- IDs are generated by hashing the provided string/int with the parent's ID.
- This creates a deterministic ID path (e.g., `Root/Sidebar/Menu/Button`).
- This ID is used to look up **Persistent State** (scroll position, animations, text input content) across frames.

### State Store vs. Frame State
- **Frame State**: Rebuilt from scratch every frame. Contains the "definition" of the UI (what you wrote in code this frame).
- **State Store**: Persists across frames. Contains "user state" (what the user changed, physics animations, scroll offsets).

### Layout Engine
The layout engine runs **after** the user code has finished defining the entire tree for the frame. This allows for complex dependency resolution (though currently it's a single-pass Flexbox-like solver).

## 3. Rendering Pipeline

The rendering is deferred.
1. **User Code**: Defines geometry logic.
2. **Layout Step**: Calculates absolute positions (`Rect`).
3. **Render Step**: Walks the tree, combining Layout Rects + Style Info to generate a `DrawList`.
4. **Backend**: Takes the `DrawList` (containing platform-agnostic commands like `DrawRect`, `DrawText`) and executes them (GL/D3D).

### SDF Rendering
Unlike traditional rasterizers, Fantasmagorie uses Signed Distance Fields in the pixel shader.
- **Advantage**: Zooming in 1000x on a rounded corner keeps it perfectly sharp.
- **Advantage**: Shadows and Blurs can be computed analytically or via compute shaders.

## 4. Platform Abstraction

All OS-specific logic is hidden behind `NativePlatformBridge`.
- **Input**: GLFW (or Win32 directly).
- **Dialogs**: Blocking/Async native file pickers.
- **IME**: Text input candidates.
